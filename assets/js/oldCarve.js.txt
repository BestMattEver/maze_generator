

var nextList=[];
nextList[0]=[];
//this function carves into a non-visited cell, and then calls itself on that cell
function carve(grid, startX, startY, speed)
{//grid is the grid array generated by gridInit
 //startx and starty represent the cell to start carving from.

//============================================DANGER WILLIAM RIKER!!==================================
  try{
   if(grid[startX][startY].beenTo === true)
   {
     console.log("we've been to this cell. jump to next in nextlist");
     var next = nextList.pop();
     carve(grid, next[0], next[1], speed);
     return;
   }
 }
 catch(e)
 {
   console.log("we're done.");
   return;
 }
//============================================DANGER WILLIAM RIKER!!==================================
 //console.log("-------carving!------")
  var newUnvisits =[]; //this array stores all unvisited neighbors of this cell (stored as indexes of grid)
  //unvisited[0]=[];
  //console.log("starty: "+startY);
  grid[startX][startY].beenTo = true; //lets make sure we dont come back to this cell...
  context1.clearRect(0, 0, width1, height1);//clear the grid
  drawGrid(grid, '#4d89a5', "#0b175b", "#2b43c6");//redraw the grid

  var thing = setTimeout(function(){ // sets a pause so we can see things happening

    //console.log("checking for unvisited neighbors of ["+startX+","+startY+"]...");

    //get all of this cell's unvisited neighbors.
    //if the cell to the north is unvisited...
    if(startY-1<0)
    {/*console.log("nope, north is off the side...");*/}
    else if(grid[startX][startY-1].beenTo === false)
    {
      //console.log("north is unvisited!");
      // nextList.push([startX,startY-1]);
      newUnvisits.push([startX,startY-1]);
    }
    else if(grid[startX][startY-1].beenTo === true)
    {/*console.log("north is visited... :(");*/}

    //if the cell to the east is unvisited...
    if(startX+1>=grid.length)
    {/*console.log("nope, east is off the side...");*/}
    else if(grid[startX+1][startY].beenTo === false)
    {
      //console.log("east is unvisited!");
      //nextList.push([startX+1,startY]);
      newUnvisits.push([startX+1,startY]);
    }
    else if(grid[startX+1][startY].beenTo === true)
    {/*console.log("east is visited... :(");*/}

    //if the cell to the south is unvisited...
    if(startY+1>=grid[0].length)
    {/*console.log("nope, south is off the side...");*/}
    else if(grid[startX][startY+1].beenTo === false)
    {
      //console.log("south is unvisited!");
      //nextList.push([startX,startY+1]);
      newUnvisits.push([startX,startY+1]);
    }
    else if(grid[startX][startY+1].beenTo === true)
    {/*console.log("south is visited... :(");*/}

    //if the cell to the west is unvisited...
    if(startX-1<0)
    {/*console.log("nope, west is off the side...");*/}
    else if(grid[startX-1][startY].beenTo === false)
    {
      //console.log("west is unvisited!");
      //nextList.push([startX-1,startY]);
      newUnvisits.push([startX-1,startY]);
    }
    else if(grid[startX-1][startY].beenTo === true)
    {/*console.log("west is visited... :(");*/}

    var next;//this is the next place we're visiting.

    // if(newUnvisits.length>0)//did we find any new unvisited neighbors?
    // {//randomly select from the newly discovered unvisited neighbors
    //
    //   for(var j=0;j<newUnvisits.length;j++)
    //   {
    //     var rand = Math.floor(Math.random() * (newUnvisits.length-1 + 1));
    //     next = newUnvisits[rand]; // assign the next variable to the chosen neighbor.
    //
    //     var temp = newUnvisits.splice(rand,1)//remove the neighbor we've decided to visit visiting from the new list.
    //
    //     //console.log("current cell?? : ["+grid[startX][startY].indexX+","+grid[startX][startY].indexY+"]");
    //     console.log("carving into: ["+next[0]+","+next[1]+"]");
    //     //break down the walls to that neighbor...
    //     if(next[1]<grid[startX][startY].indexY)
    //     {console.log("GOING UP!");
    //       grid[startX][startY].wallN = false;
    //       grid[startX][startY-1].wallS = false;
    //     }
    //     else if(next[0]>grid[startX][startY].indexX)
    //     {console.log("GOING RIGHT!");
    //       grid[startX][startY].wallE = false;
    //       grid[startX+1][startY].wallW = false;
    //     }
    //     else if(next[1]>grid[startX][startY].indexY)
    //     {console.log("GOING DOWN!");
    //       grid[startX][startY].wallS = false;
    //       grid[startX][startY+1].wallN = false;
    //     }
    //     else if(next[0]<grid[startX][startY].indexX)
    //     {console.log("GOING LEFT!");
    //       grid[startX][startY].wallW = false;
    //       grid[startX-1][startY].wallE = false;
    //     }
    //     //console.log(next[0]);
    //
    //     console.log('going to the next neighbor.');
    //     carve(grid, next[0], next[1], speed); //go visit a random neighbor!
    //   }//end for
    //
    // }//end new neighbors found if
    // else
    // {//if no new unvisited neighbors were found, get out of the function.
    //   return;
    // }//end else.
//==================================================DANGER WILL ROBINSON!!===========================================================
    if(newUnvisits.length>0)//did we find any new unvisited neighbors?
    {//randomly select from the newly discovered unvisited neighbors
      var rand = Math.floor(Math.random() * (newUnvisits.length-1 + 1));
      next = newUnvisits[rand]; // assign the next variable to the chosen neighbor.

      var temp = newUnvisits.splice(rand,1)//remove the neighbor we've decided to visit visiting from the new list.

      //now push the rest of the new neighbors into the nextlist array for use later.
      for(var j=0;j<newUnvisits.length;j++)
      {
        nextList.push(newUnvisits[j]);
      }
    }//end new neighbors found if
    else
    {//if no new unvisited neighbors were found, just go back to the most recent unvisited neighbor.
      console.log("nextlist: ");
      console.log(nextList);
      next = nextList.pop();
    }//end else.

      //console.log("current cell?? : ["+grid[startX][startY].indexX+","+grid[startX][startY].indexY+"]");
      console.log("carving into: ["+next[0]+","+next[1]+"]");
      //break down the walls to that neighbor...
      if(next[1]<grid[startX][startY].indexY)
      {console.log("GOING UP!");
        grid[startX][startY].wallN = false;
        grid[startX][startY-1].wallS = false;

      }
      else if(next[0]>grid[startX][startY].indexX)
      {console.log("GOING RIGHT!");
        grid[startX][startY].wallE = false;
        grid[startX+1][startY].wallW = false;

      }
      else if(next[1]>grid[startX][startY].indexY)
      {console.log("GOING DOWN!");
        grid[startX][startY].wallS = false;
        grid[startX][startY+1].wallN = false;

      }
      else if(next[0]<grid[startX][startY].indexX)
      {console.log("GOING LEFT!");
        grid[startX][startY].wallW = false;
        grid[startX-1][startY].wallE = false;

      }
      //console.log(next[0]);

      console.log('going to the next neighbor.');
      // context1.clearRect(0, 0, width1, height1);//clear the grid
      // drawGrid(grid, '#4d89a5', "#0b175b", "#2b43c6");//redraw the grid
      carve(grid, next[0], next[1], speed); //go visit a random neighbor!

//==================================================DANGER WILL ROBINSON!!===========================================================
  }, speed);//end set timeout..?
  return;
}//end carve
